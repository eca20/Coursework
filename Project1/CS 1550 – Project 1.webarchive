bplist00—_WebMainResource’	
_WebResourceFrameName_WebResourceData_WebResourceMIMEType_WebResourceTextEncodingName^WebResourceURLPOã\<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="Generator" content="Microsoft Word 15 (filtered)">
<title>CS 1550 ‚Äì Project 1</title>
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
@font-face
	{font-family:Consolas;
	panose-1:2 11 6 9 2 2 4 3 2 4;}
@font-face
	{font-family:Cambria;
	panose-1:2 4 5 3 5 4 6 3 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri",sans-serif;}
h1
	{mso-style-link:"Heading 1 Char";
	margin-top:24.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Cambria",serif;}
h1.CxSpFirst
	{mso-style-link:"Heading 1 Char";
	margin-top:24.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Cambria",serif;}
h1.CxSpMiddle
	{mso-style-link:"Heading 1 Char";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Cambria",serif;}
h1.CxSpLast
	{mso-style-link:"Heading 1 Char";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Cambria",serif;}
h2
	{mso-style-link:"Heading 2 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:13.0pt;
	font-family:"Cambria",serif;}
h3
	{mso-style-link:"Heading 3 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:112%;
	font-size:11.0pt;
	font-family:"Cambria",serif;}
h4
	{mso-style-link:"Heading 4 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Cambria",serif;
	font-style:italic;}
h5
	{mso-style-link:"Heading 5 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Cambria",serif;
	color:#7F7F7F;}
h6
	{mso-style-link:"Heading 6 Char";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:112%;
	font-size:11.0pt;
	font-family:"Cambria",serif;
	color:#7F7F7F;
	font-style:italic;}
p.MsoHeading7, li.MsoHeading7, div.MsoHeading7
	{mso-style-link:"Heading 7 Char";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Cambria",serif;
	font-style:italic;}
p.MsoHeading8, li.MsoHeading8, div.MsoHeading8
	{mso-style-link:"Heading 8 Char";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:10.0pt;
	font-family:"Cambria",serif;}
p.MsoHeading9, li.MsoHeading9, div.MsoHeading9
	{mso-style-link:"Heading 9 Char";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:10.0pt;
	font-family:"Cambria",serif;
	letter-spacing:.25pt;
	font-style:italic;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri",sans-serif;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{mso-style-link:"Title Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:26.0pt;
	font-family:"Cambria",serif;
	letter-spacing:.25pt;}
p.MsoTitleCxSpFirst, li.MsoTitleCxSpFirst, div.MsoTitleCxSpFirst
	{mso-style-link:"Title Char";
	margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:26.0pt;
	font-family:"Cambria",serif;
	letter-spacing:.25pt;}
p.MsoTitleCxSpMiddle, li.MsoTitleCxSpMiddle, div.MsoTitleCxSpMiddle
	{mso-style-link:"Title Char";
	margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:26.0pt;
	font-family:"Cambria",serif;
	letter-spacing:.25pt;}
p.MsoTitleCxSpLast, li.MsoTitleCxSpLast, div.MsoTitleCxSpLast
	{mso-style-link:"Title Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:26.0pt;
	font-family:"Cambria",serif;
	letter-spacing:.25pt;}
p.MsoSubtitle, li.MsoSubtitle, div.MsoSubtitle
	{mso-style-link:"Subtitle Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:30.0pt;
	margin-left:0in;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Cambria",serif;
	letter-spacing:.65pt;
	font-style:italic;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:#954F72;
	text-decoration:underline;}
em
	{letter-spacing:.5pt;
	border:none;
	font-weight:bold;}
span.MsoSubtleEmphasis
	{font-style:italic;}
span.MsoIntenseEmphasis
	{font-weight:bold;}
span.MsoSubtleReference
	{font-variant:small-caps;}
span.MsoIntenseReference
	{font-variant:small-caps;
	letter-spacing:.25pt;
	text-decoration:underline;}
span.MsoBookTitle
	{font-variant:small-caps;
	letter-spacing:.25pt;
	font-style:italic;}
p.MsoTocHeading, li.MsoTocHeading, div.MsoTocHeading
	{margin-top:24.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Cambria",serif;
	font-weight:bold;}
p.MsoTocHeadingCxSpFirst, li.MsoTocHeadingCxSpFirst, div.MsoTocHeadingCxSpFirst
	{margin-top:24.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Cambria",serif;
	font-weight:bold;}
p.MsoTocHeadingCxSpMiddle, li.MsoTocHeadingCxSpMiddle, div.MsoTocHeadingCxSpMiddle
	{margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Cambria",serif;
	font-weight:bold;}
p.MsoTocHeadingCxSpLast, li.MsoTocHeadingCxSpLast, div.MsoTocHeadingCxSpLast
	{margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Cambria",serif;
	font-weight:bold;}
span.TitleChar
	{mso-style-name:"Title Char";
	mso-style-link:Title;
	font-family:"Cambria",serif;
	letter-spacing:.25pt;}
span.Heading1Char
	{mso-style-name:"Heading 1 Char";
	mso-style-link:"Heading 1";
	font-family:"Cambria",serif;
	font-weight:bold;}
p.Code, li.Code, div.Code
	{mso-style-name:Code;
	mso-style-link:"Code Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:Consolas;}
span.CodeChar
	{mso-style-name:"Code Char";
	mso-style-link:Code;
	font-family:Consolas;}
span.Heading2Char
	{mso-style-name:"Heading 2 Char";
	mso-style-link:"Heading 2";
	font-family:"Cambria",serif;
	font-weight:bold;}
span.Heading3Char
	{mso-style-name:"Heading 3 Char";
	mso-style-link:"Heading 3";
	font-family:"Cambria",serif;
	font-weight:bold;}
span.Heading4Char
	{mso-style-name:"Heading 4 Char";
	mso-style-link:"Heading 4";
	font-family:"Cambria",serif;
	font-weight:bold;
	font-style:italic;}
span.Heading5Char
	{mso-style-name:"Heading 5 Char";
	mso-style-link:"Heading 5";
	font-family:"Cambria",serif;
	color:#7F7F7F;
	font-weight:bold;}
span.Heading6Char
	{mso-style-name:"Heading 6 Char";
	mso-style-link:"Heading 6";
	font-family:"Cambria",serif;
	color:#7F7F7F;
	font-weight:bold;
	font-style:italic;}
span.Heading7Char
	{mso-style-name:"Heading 7 Char";
	mso-style-link:"Heading 7";
	font-family:"Cambria",serif;
	font-style:italic;}
span.Heading8Char
	{mso-style-name:"Heading 8 Char";
	mso-style-link:"Heading 8";
	font-family:"Cambria",serif;}
span.Heading9Char
	{mso-style-name:"Heading 9 Char";
	mso-style-link:"Heading 9";
	font-family:"Cambria",serif;
	letter-spacing:.25pt;
	font-style:italic;}
span.SubtitleChar
	{mso-style-name:"Subtitle Char";
	mso-style-link:Subtitle;
	font-family:"Cambria",serif;
	letter-spacing:.65pt;
	font-style:italic;}
span.ColorfulGrid-Accent1Char
	{mso-style-name:"Colorful Grid - Accent 1 Char";
	mso-style-link:"Colorful Grid - Accent 1";
	font-style:italic;}
span.LightShading-Accent2Char
	{mso-style-name:"Light Shading - Accent 2 Char";
	mso-style-link:"Light Shading - Accent 2";
	font-weight:bold;
	font-style:italic;}
 /* Page Definitions */
 @page WordSection1
	{size:8.5in 11.0in;
	margin:1.0in 1.0in 1.0in 1.0in;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>

</head>

<body lang="EN-US" link="blue" vlink="#954F72">

<div class="WordSection1">

<div style="border:none;border-bottom:solid windowtext 1.0pt;padding:0in 0in 1.0pt 0in">

<p class="MsoTitleCxSpFirst">CS 1550 ‚Äì Project 1: Double-Buffered Graphics
Library</p>

<p class="MsoTitleCxSpLast"><span style="font-size:22.0pt">Due: Sunday, June 10,
2018, by 11:59pm</span></p>

</div>

<h1 style="margin-top:.25in">Project Description</h1>

<p class="MsoNormal">Your instructor was learning ARM assembly language over a
prior summer break and was trying to make some projects for CS/COE 0447 to do.
While text-based programs are okay, it‚Äôs really the graphical programs that
make it a bit more interesting. So your instructor started to write a graphics
library so the students could make a simple game. </p>

<p class="MsoNormal">In doing so, he noticed that a lot of the basic functionality
the library provided was accessing the low-level operating system features that
we talk about in 1550. The light bulb went off over his head, and project 1 was
born.</p>

<p class="MsoNormal">In this project, you‚Äôll be writing a small graphics library
that can set a pixel to a particular color, draw some basic shapes, and read
keypresses.</p>

<h1>How it Will Work</h1>

<p class="MsoNormal">You will provide the following library functions (explained
further below):</p>

<div align="center">

<table class="MsoNormalTable" border="1" cellspacing="0" cellpadding="0" width="102%" style="width:102.46%;border-collapse:collapse;border:none">
 <tbody><tr style="height:.3in">
  <td width="72%" style="width:72.02%;border:solid #404040 1.0pt;border-right:
  none;background:black;padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2"><b><span style="color:white">Library Call</span></b></p>
  </td>
  <td width="27%" style="width:27.98%;border:solid #404040 1.0pt;border-left:
  none;background:black;padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2"><b><span style="color:white">System Call(s) used</span></b></p>
  </td>
 </tr>
 <tr style="height:.3in">
  <td width="72%" style="width:72.02%;border-top:none;border-left:solid #404040 1.0pt;
  border-bottom:solid #404040 1.0pt;border-right:none;background:silver;
  padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2"><b>void init_graphics()</b></p>
  </td>
  <td width="27%" style="width:27.98%;border-top:none;border-left:none;
  border-bottom:solid #404040 1.0pt;border-right:solid #404040 1.0pt;
  background:silver;padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2">open, ioctl, mmap</p>
  </td>
 </tr>
 <tr style="height:.3in">
  <td width="72%" style="width:72.02%;border-top:none;border-left:solid #404040 1.0pt;
  border-bottom:solid #404040 1.0pt;border-right:none;padding:0in 5.4pt 0in 5.4pt;
  height:.3in">
  <p class="MsoTableMediumGrid2"><b>void exit_graphics()</b></p>
  </td>
  <td width="27%" style="width:27.98%;border-top:none;border-left:none;
  border-bottom:solid #404040 1.0pt;border-right:solid #404040 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2">ioctl</p>
  </td>
 </tr>
 <tr style="height:.3in">
  <td width="72%" style="width:72.02%;border-top:none;border-left:solid #404040 1.0pt;
  border-bottom:solid #404040 1.0pt;border-right:none;background:silver;
  padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2"><b>char getkey()</b></p>
  </td>
  <td width="27%" style="width:27.98%;border-top:none;border-left:none;
  border-bottom:solid #404040 1.0pt;border-right:solid #404040 1.0pt;
  background:silver;padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2">select, read</p>
  </td>
 </tr>
 <tr style="height:.3in">
  <td width="72%" style="width:72.02%;border-top:none;border-left:solid #404040 1.0pt;
  border-bottom:solid #404040 1.0pt;border-right:none;padding:0in 5.4pt 0in 5.4pt;
  height:.3in">
  <p class="MsoTableMediumGrid2"><b>void sleep_ms(long ms)</b></p>
  </td>
  <td width="27%" style="width:27.98%;border-top:none;border-left:none;
  border-bottom:solid #404040 1.0pt;border-right:solid #404040 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2">nanosleep</p>
  </td>
 </tr>
 <tr style="height:.3in">
  <td width="72%" style="width:72.02%;border-top:none;border-left:solid #404040 1.0pt;
  border-bottom:solid #404040 1.0pt;border-right:none;background:silver;
  padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2"><b>void clear_screen(void *img)</b></p>
  </td>
  <td width="27%" style="width:27.98%;border-top:none;border-left:none;
  border-bottom:solid #404040 1.0pt;border-right:solid #404040 1.0pt;
  background:silver;padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2">&nbsp;</p>
  </td>
 </tr>
 <tr style="height:.3in">
  <td width="72%" style="width:72.02%;border-top:none;border-left:solid #404040 1.0pt;
  border-bottom:solid #404040 1.0pt;border-right:none;padding:0in 5.4pt 0in 5.4pt;
  height:.3in">
  <p class="MsoTableMediumGrid2"><b>void draw_pixel(void *img, int x, int y,
  color_t color)</b></p>
  </td>
  <td width="27%" style="width:27.98%;border-top:none;border-left:none;
  border-bottom:solid #404040 1.0pt;border-right:solid #404040 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2">&nbsp;</p>
  </td>
 </tr>
 <tr style="height:.3in">
  <td width="72%" style="width:72.02%;border-top:none;border-left:solid #404040 1.0pt;
  border-bottom:solid #404040 1.0pt;border-right:none;background:silver;
  padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2"><b>void draw_line(void *img, int x1, int y1, int
  x2, int y2, color_t c)</b></p>
  </td>
  <td width="27%" style="width:27.98%;border-top:none;border-left:none;
  border-bottom:solid #404040 1.0pt;border-right:solid #404040 1.0pt;
  background:silver;padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2">&nbsp;</p>
  </td>
 </tr>
 <tr style="height:.3in">
  <td width="72%" style="width:72.02%;border-top:none;border-left:solid #404040 1.0pt;
  border-bottom:solid #404040 1.0pt;border-right:none;padding:0in 5.4pt 0in 5.4pt;
  height:.3in">
  <p class="MsoTableMediumGrid2"><b>void *new_offscreen_buffer()</b></p>
  </td>
  <td width="27%" style="width:27.98%;border-top:none;border-left:none;
  border-bottom:solid #404040 1.0pt;border-right:solid #404040 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2">mmap</p>
  </td>
 </tr>
 <tr style="height:.3in">
  <td width="72%" style="width:72.02%;border-top:none;border-left:solid #404040 1.0pt;
  border-bottom:solid #404040 1.0pt;border-right:none;background:#BFBFBF;
  padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2"><b>void blit(void *src)</b></p>
  </td>
  <td width="27%" style="width:27.98%;border-top:none;border-left:none;
  border-bottom:solid #404040 1.0pt;border-right:solid #404040 1.0pt;
  background:#BFBFBF;padding:0in 5.4pt 0in 5.4pt;height:.3in">
  <p class="MsoTableMediumGrid2">&nbsp;</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="MsoNormal">&nbsp;</p>

<p class="MsoNormal">Each library function must be implemented using only the
Linux syscalls. You may <b>not</b> use any C standard library functions in your
library anywhere. </p>

<h2>init_graphics()</h2>

<p class="MsoNormal">In this function, you should do any work necessary to
initialize the graphics library. This will be at least these five things:</p>

<ol style="margin-top:0in" start="1" type="1">
 <li class="MsoNormal">You will need to open the graphics device. The memory that
     backs a video display is often called a <b>framebuffer</b>. In the version
     of Linux we are using, the kernel has been built to allow you direct
     access to the framebuffer. As we learned in 449, hardware devices in
     Unix/Linux are usually exposed to user programs via the /dev/ filesystem.
     In our case, we will find a file, <span style="font-size:9.0pt;line-height:
     115%;font-family:Consolas">/dev/fb0</span>, that represents the first
     (zero-th) framebuffer attached to the computer. <br>
     <br>
     Since it appears to be a file, it can be opened using the open() syscall.
     To set a pixel, we only need to do basic file operations. You could seek
     to a location and then write some data. However, we will have a better
     way.</li>
 <li class="MsoNormal">We can do something special to make writing to the screen
     easier than using a whole bunch of seeks and writes. Since each of those
     is a system call on their own, using them to do a lot of graphics
     operations would be slow. Instead, we can ask the OS to map a file into
     our address space so that we can treat it as an array and use loads and
     stores to manipulate the file contents. We will be covering this more
     later when we discuss memory management, but for now, we want to use this
     idea of <b>memory mapping</b> for our library. The mmap() system call
     takes a file descriptor from open (and a bunch of other parameters) and
     returns a void *, an address in our address space that now represents the
     contents of the file. That means that we can use pointer arithmetic or
     array subscripting to set each individual pixel, provided we know how many
     pixels there are and how many bytes of data is associated with each pixel.
     <br>
     <br>
     One note is that we must use the MAP_SHARED parameter to <span style="font-size:9.0pt;line-height:115%;font-family:Consolas">mmap()</span>
     because other parts of the OS want to use the framebuffer too.</li>
 <li class="MsoNormal">In order to use the memory mapping we have just
     established correctly, we need some information about the screen. We need
     to know the resolution (number of pixels) in the x and y directions as
     well as the bit-depth: the amount of colors we can use. The machine that
     QEMU is configured to emulate is in a basic 640x480 mode with 16-bit
     color. This means that there are 640 pixels in the x direction (0 is
     leftmost and 639 is rightmost) and 480 pixels in the y direction (0 is
     topmost, 479 is bottommost). In 16-bit color, we store the intensity of
     the three primary colors of additive light, Red, Green, and Blue, all
     packed together into a single 16-bit number.&nbsp; Since 16 isn‚Äôt evenly
     divisible by three (RGB), we devote the upper 5 bits to storing red intensity
     (0-31), the middle 6 bits to store green intensity (0-63), and the low
     order 5 bits to store blue intensity (0-31). <br>
     <br>
     You can then use <span style="font-size:9.0pt;line-height:115%;font-family:
     Consolas">typedef</span><span style="font-size:9.0pt;line-height:115%"> </span>to
     make a color type, <span style="font-size:9.0pt;line-height:115%;
     font-family:Consolas">color_t</span>, that is an unsigned 16-bit value.
     You must also make a macro named RGB to encode a <span style="font-size:
     9.0pt;line-height:115%;font-family:Consolas">color_t</span> from three RGB
     values using bit shifting and masking to make a single 16-bit number.<br>
     <br>
     To get the screen size and bits per pixels, we can use a special system
     call: <span style="font-size:9.0pt;line-height:115%;font-family:Consolas">ioctl</span>.
     This system call is used to query and set parameters for almost any device
     connected to the system. You pass it a file descriptor and a particular
     number that represents the request you‚Äôre making of that device. We will
     use two requests: FBIOGET_VSCREENINFO and FBIOGET_FSCREENINFO. The first
     will give back a <span style="font-size:9.0pt;line-height:115%;font-family:
     Consolas">struct fb_var_screeninfo</span> that will give the virtual
     resolution. The second will give back a <span style="font-size:9.0pt;
     line-height:115%;font-family:Consolas">struct fb_fix_screeninfo</span>
     from which we can determine the bit depth. The total size of the <span style="font-size:9.0pt;line-height:115%;font-family:Consolas">mmap()</span>‚Äôed
     file would be the <span style="font-size:9.0pt;line-height:115%;
     font-family:Consolas">yres_virtual</span> field of the first struct
     multiplied by the <span style="font-size:9.0pt;line-height:115%;
     font-family:Consolas">line_length</span> field of the second.</li>
 <li class="MsoNormal">We will use an <b>ANSI escape code</b> to clear the screen
     rather than blanking it by drawing a giant rectangle of black pixels. ANSI
     escape codes are a sequence of characters that are not meant to be
     displayed as text but rather interpreted as commands to the terminal. We
     can print the string ‚Äú\033[2J‚Äù to tell the terminal to clear itself. Note
     that this uses an octal escape sequence, where \033 is only one character.</li>
 <li class="MsoNormal">Our final step is to use the <span style="font-size:9.0pt;
     line-height:115%;font-family:Consolas">ioctl</span> system call to disable
     keypress echo (displaying the keys as you‚Äôre typing on the screen
     automatically) and buffering the keypresses. The commands we will need are
     TCGETS and TCSETS. These will yield or take a <span style="font-size:9.0pt;
     line-height:115%;font-family:Consolas">struct termios</span> that
     describes the current terminal settings. You will want to disable
     canonical mode by unsetting the ICANON bit and disabling ECHO by forcing
     that bit to zero as well. <br>
     <br>
     There is one problem with this. When the terminal settings are changed,
     the changes last even after the program terminates. That‚Äôs why we have the
     exit_graphics() call. It can clean up the terminal settings by restoring
     them to what they were prior to us changing them.<br>
     <br>
     That handles the normal termination, but it‚Äôs always possible that our
     program abnormally terminates, i.e., it crashes. In that case when you try
     to type something at the commandline, it will not show up on the screen.
     What you‚Äôre typing is still working, but you cannot see it. A reboot will
     fix this, but I found it useful to make a little helper program I called
     ‚Äúfix‚Äù to turn echo back on in this event.</li>
</ol>

<h2>exit_graphics()</h2>

<p class="MsoNormal">This is your function to undo whatever it is that needs to
be cleaned up before the program exits. Many things will be cleaned up
automatically if we forget, for instance files will be closed and memory can be
unmapped. It‚Äôs always a good idea to do it yourself with <span style="font-size:9.0pt;line-height:115%;font-family:Consolas">close()</span><span style="font-size:9.0pt;line-height:115%"> </span>and <span style="font-size:
9.0pt;line-height:115%;font-family:Consolas">munmap()</span> though.</p>

<p class="MsoNormal">What you‚Äôll definitely need to do is to make an ioctl() to
reenable key press echoing and buffering as described above.</p>

<h2>getkey()</h2>

<p class="MsoNormal">To make games, we probably want some sort of user input. We
will use key press input and we can read a single character using the <span style="font-size:9.0pt;line-height:115%;font-family:Consolas">read()</span>
system call. However, <span style="font-size:9.0pt;line-height:115%;font-family:
Consolas">read()</span> is blocking and will cause our program to not draw
unless the user has typed something. Instead, we want to know if there is a
keypress at all, and if so, read it.</p>

<p class="MsoNormal">This can be done using the Linux non-blocking system call <span style="font-size:9.0pt;line-height:115%;font-family:Consolas">select()</span>.</p>

<h2>sleep_ms()</h2>

<p class="MsoNormal">We will use the system call <span style="font-size:9.0pt;
line-height:115%;font-family:Consolas">nanosleep()</span> to make our program
sleep between frames of graphics being drawn. From its name you can guess that
it has nanosecond precision, but we don‚Äôt need that level of granularity. We
will instead sleep for a specified number of milliseconds and just multiply
that by 1,000,000.</p>

<p class="MsoNormal">We do not need to worry about the call being interrupted and
so the second parameter to <span style="font-size:9.0pt;line-height:115%;
font-family:Consolas">nanosleep()</span> can be NULL.</p>

<h2>new_offscreen_buffer()</h2>

<p class="MsoNormal">If we draw directly to the framebuffer, a complex scene may
render slow enough to see each part appear on screen. To get the illusion of
more fluid graphics, a technique known as <b>double buffering</b> is often
used. We make a duplicate array of pixels in RAM rather than representing any
hardware device. We draw to this ‚Äúoffscreen buffer‚Äù by making it the target of all
our graphical operations. And when it‚Äôs time to show the completed scene, we
copy the offscreen buffer into the framebuffer in one big memory copy
operation, known as a <b>blit</b> (see the next section).</p>

<p class="MsoNormal">For the <span style="font-size:9.0pt;line-height:115%;
font-family:Consolas">new_offscreen_buffer()</span> function, we will allocate
a screen-sized region of our address space. Normally, we‚Äôd use the C Standard
Library function <span style="font-size:9.0pt;line-height:115%;font-family:
Consolas">malloc()</span><span style="font-size:9.0pt;line-height:115%"> </span>to
do this, but we‚Äôre avoiding all library calls. So we will once again ask the OS
for memory directly, by using the same <span style="font-size:9.0pt;line-height:
115%;font-family:Consolas">mmap</span>() system call we used in <span style="font-size:9.0pt;line-height:115%;font-family:Consolas">init_graphics()</span>.
This time, we will pass slightly different parameters. The memory should still
be readable and writeable, but rather than <span style="font-size:9.0pt;
line-height:115%;font-family:Consolas">MAP_SHARED</span>, we wish to make a
private, anonymous allocation. Anonymous means that we do not have a file to
map into the region. Use <span style="font-size:9.0pt;line-height:115%;
font-family:Consolas">MAP_PRIVATE | MAP_ANONYMOUS</span> and a file descriptor
of -1 to use <span style="font-size:9.0pt;line-height:115%;font-family:Consolas">mmap()</span><span style="font-size:9.0pt;line-height:115%"> </span>just like <span style="font-size:9.0pt;line-height:115%;font-family:Consolas">malloc()</span>.
The return value (if successful) will be the address of an appropriately-sized
(screen-sized) contiguous block of address space. Return that address back to
the caller.</p>

<h2>blit()</h2>

<p class="MsoNormal">A blit is simply a memory copy from our offscreen buffer to
the framebuffer. If we were using the C Standard Library, we‚Äôd do this using <span style="font-size:9.0pt;line-height:115%;font-family:Consolas">memcpy()</span>.
But we must write it ourselves. So, use one or two <span style="font-size:9.0pt;
line-height:115%;font-family:Consolas">for</span><span style="font-size:9.0pt;
line-height:115%"> </span>loops and copy every byte from the source offscreen
buffer onto the frame buffer.</p>

<h2>draw_pixel()</h2>

<p class="MsoNormal">This is the main drawing code, where the work is actually
done. We want to set the pixel at coordinate (x, y) to the specified color. You
will use the given coordinates to scale the base address of the memory-mapped
framebuffer using pointer arithmetic. The image will be stored in <b>row-major
order</b>, meaning that the first row starts at offset 0 and then that is
followed by the second row of pixels, and so on.</p>

<h2>draw_line()</h2>

<p class="MsoNormal">Using draw_pixel, make a line from (x1, y1) to (x2, y2). Use
Bresenham‚Äôs Algorithm with only integer math. Find your favorite online source
to do so (and please cite the source in a comment), but make sure your
implementation works for all valid coordinates and slopes.</p>

<h2>clear_screen()</h2>

<p class="MsoNormal">When we want to blank out our offscreen buffer or our
framebuffer, we can just copy over every byte with the value zero. So, much
like our <span style="font-size:10.0pt;line-height:115%;font-family:Consolas">blit()</span>,
loop over the image buffer parameter and set each byte to zero.</p>

<h1>Installing and Running QEMU</h1>

<h2>For everyone</h2>

<p class="MsoNormal">Download the qemu-arm.zip file from the website and extract
the files into a folder.</p>

<h2>On Windows</h2>

<p class="MsoNormal">Double-click the start.bat file in the folder to launch QEMU.</p>

<h2>On Mac OS X</h2>

<p class="MsoNormal">Install QEMU through Homebrew. If you don‚Äôt have Homebrew,
open a terminal and type:</p>

<p class="MsoNormal"><span style="font-size:9.0pt;line-height:115%;font-family:
Consolas">ruby -e "$(curl -fsSL <a href="https://raw.github.com/Homebrew/homebrew/go/install">https://raw.github.com/Homebrew/homebrew/go/install</a>)"</span></p>

<p class="MsoNormal">Go through the install steps. When done, install qemu by
typing:</p>

<p class="MsoNormal"><span style="font-size:9.0pt;line-height:115%;font-family:
Consolas">brew install qemu</span></p>

<p class="MsoNormal">That will install qemu. Now you can run <span style="font-size:9.0pt;line-height:115%;font-family:Consolas">start.sh</span> from
the terminal in the unzipped folder to launch qemu.</p>

<h2>On Linux</h2>

<p class="MsoNormal">Using your appropriate package manager, install
qemu-system-arm, likely part of your distro‚Äôs qemu package. </p>

<p class="MsoNormal">Then run <span style="font-size:9.0pt;line-height:115%;
font-family:Consolas">start.sh</span> in the zipped folder to launch qemu.</p>

<h1>Setting up the Development Environment</h1>

<p class="MsoNormal">To keep downloads small, the disk image we have provided
does not have a full development environment installed. To install gcc, gdb,
and ssh/scp, run the script:</p>

<p class="MsoNormal"><span style="font-size:9.0pt;line-height:115%;font-family:
Consolas">./devtools.sh</span></p>

<p class="MsoNormal">When this finishes downloading and installing, you should
have the ability to use most basic Linux commands, nano for text editing, and
gcc, gdb, and ssh/scp/sftp for transferring files. These commands will survive
a reboot, so this only needs to be done once.</p>

<p class="MsoNormal">If you want to install other programs, you may use the Tiny
Core Linux distribution‚Äôs package installer:</p>

<p class="MsoNormal"><span style="font-size:9.0pt;line-height:115%;font-family:
Consolas">tce</span></p>

<p class="MsoNormal">This lets you search for a particular package or program
name and install it.</p>

<p class="MsoNormal">After you‚Äôve finished installing the tools, you may wish to
make a backup of the disk image in case something happens and you don‚Äôt feel
like redoing all of these steps. </p>

<p class="MsoNormal">Shutdown linux using the command (rebooting has been turned
into poweroff by an option to QEMU):</p>

<p class="MsoNormal"><span style="font-size:9.0pt;line-height:115%;font-family:
Consolas">sudo reboot</span></p>

<p class="MsoNormal">Then, make a copy of <span style="font-size:9.0pt;
line-height:115%;font-family:Consolas">disk.qcow2</span><span style="font-size:
9.0pt;line-height:115%"> </span>someplace safe. If things go wrong, you can
always restore back to this point by replacing the <span style="font-size:9.0pt;
line-height:115%;font-family:Consolas">disk.qcow2</span><span style="font-size:
9.0pt;line-height:115%"> </span>file in this directory with the one you‚Äôve
backed up.</p>

<h1>Copying Files In and Out of QEMU</h1>

<p class="MsoNormal">With the dev tools installed you can use scp (secure copy)
to transfer files in and out of QEMU.</p>

<p class="MsoNormal">You can download the test driver program from thoth with the
command:</p>

<p class="MsoNormal"><span style="font-size:9.0pt;line-height:115%;font-family:
Consolas">scp USERNAME@thoth.cs.pitt.edu:/u/OSLab/original/hilbert.c .</span></p>

<p class="MsoNormal">You can backup a file named library.c to your private folder
with:</p>

<p class="MsoNormal"><span style="font-size:9.0pt;line-height:115%;font-family:
Consolas">scp library.c USERNAME@thoth.cs.pitt.edu:private</span></p>

<h1>File Backups</h1>

<p class="MsoNormal">One of the major contributions the university provides for
the AFS filesystem is nightly backups. However, the <span style="font-size:
10.0pt;line-height:115%;font-family:Consolas">/u/OSLab/</span> partition is not
part of AFS space. Thus, any files you modify under your personal directory in <span style="font-size:10.0pt;line-height:115%;font-family:Consolas">/u/OSLab/</span>
are not backed up. If there is a catastrophic disk failure, all of your work
will be irrecoverably lost. As such, it is my recommendation that you:</p>

<p class="MsoNormal"><b><span style="font-size:12.0pt;line-height:115%;
color:red">Backup all the files you change under </span></b><b><span style="font-size:12.0pt;line-height:115%;font-family:Consolas;color:red">/u/OSLab</span></b><b><span style="font-size:12.0pt;line-height:115%;color:red"> </span></b><b><span style="font-size:12.0pt;line-height:115%;font-family:Consolas;color:red">or</span></b><b><span style="font-size:12.0pt;line-height:115%;color:red"> </span></b><b><span style="font-size:12.0pt;line-height:115%;font-family:Consolas;color:red">QEMU</span></b><b><span style="font-size:12.0pt;line-height:115%;color:red"> to your </span></b><b><span style="font-size:12.0pt;line-height:115%;font-family:Consolas;color:red">~/private/</span></b><b><span style="font-size:12.0pt;line-height:115%;color:red"> directory frequently!</span></b></p>

<p class="MsoNormal">Loss of work not backed up is not grounds for an extension. <span style="color:red;text-transform:uppercase">You have been warned</span>.</p>

<h1 style="line-height:150%">Requirements and Submission</h1>

<p class="MsoNormal">You need to submit:</p>

<ul style="margin-top:0in" type="disc">
 <li class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
     150%">Your library.c file containing the implementation of the above
     functions using pure Linux system calls and no C Standard Library Calls</li>
 <li class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
     150%">A graphics.h header file which defines prototypes for all the
     ‚Äúpublic‚Äù functions, your color_t typedef, and your RGB conversion macro.</li>
 <li class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
     150%">An additional driver program of your design that shows the required
     function calls working</li>
</ul>

<p class="MsoNormal" style="margin-bottom:0in;margin-bottom:.0001pt;line-height:
normal">&nbsp;</p>

<p class="MsoNormal">Make a tar.gz file named <span style="font-size:10.0pt;
line-height:115%;font-family:Consolas">USERNAME-project1.tar.gz</span></p>

<p class="MsoNormal">Copy it to <span style="font-size:10.0pt;line-height:115%;
font-family:Consolas">~jrmst106/submit/1550/ </span>by the deadline for credit.</p>

</div>




</body></html>Ytext/htmlUUTF-8_Qhttp://people.cs.pitt.edu/~jmisurda/teaching/cs1550/2187/cs1550-2187-project1.htm    ( ? Q g Ö î ïãıãˇå                           åY